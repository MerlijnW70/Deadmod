<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deadmod - PixiJS WebGL Graph</title>
    <!-- Security: SRI hash ensures CDN integrity -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"
            integrity="sha384-RCv8k7M0svH2bjL5ymf31cHEJj03dM6v/swaMFDv7mjIAbbxLfOQlNyLRN4qyGxe"
            crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d0d1a;
            color: #eee;
            overflow: hidden;
        }
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            gap: 20px;
        }
        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #e94560;
        }
        #header .badge {
            background: #e94560;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }
        .stat {
            font-size: 13px;
            color: #aaa;
        }
        .stat-value {
            font-weight: bold;
            margin-left: 5px;
        }
        .stat-value.green { color: #90EE90; }
        .stat-value.red { color: #F08080; }
        #canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 320px;
            bottom: 0;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }
        #controls button {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 10px;
            background: rgba(22, 33, 62, 0.9);
            color: #eee;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        #controls button:hover { background: #0f3460; transform: scale(1.05); }
        #controls button.active { background: #e94560; }
        #legend {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #0f3460;
            border-radius: 10px;
            padding: 15px;
            font-size: 12px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        #legend h4 { margin-bottom: 10px; color: #e94560; }
        .legend-item { display: flex; align-items: center; gap: 10px; margin: 6px 0; }
        .legend-color { width: 18px; height: 18px; border-radius: 50%; }
        /* Inspector Panel */
        #inspector {
            position: fixed;
            top: 50px;
            right: 0;
            width: 320px;
            bottom: 0;
            background: #16213e;
            border-left: 1px solid #0f3460;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }
        #inspector h2 {
            color: #e94560;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #inspector .section { margin-bottom: 20px; }
        #inspector .section h3 {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 10px;
        }
        #inspector .value {
            font-size: 15px;
            color: #fff;
            margin-bottom: 6px;
        }
        #inspector .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        #inspector .stat-label { color: #666; }
        #inspector .stat-num { font-weight: bold; }
        #inspector .stat-num.green { color: #90EE90; }
        #inspector .stat-num.red { color: #F08080; }
        #inspector .cluster-tag {
            display: inline-block;
            padding: 5px 12px;
            background: rgba(233, 69, 96, 0.15);
            color: #e94560;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 6px;
        }
        #inspector .empty { color: #555; font-style: italic; }
        #inspector .dep-list { max-height: 160px; overflow-y: auto; }
        #inspector .dep-item {
            padding: 6px 10px;
            margin: 3px 0;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
        }
        #inspector .dep-item:hover { background: rgba(233, 69, 96, 0.2); }
        #inspector .dep-item.dead { color: #F08080; }
        #fps {
            position: fixed;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: #0f0;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Deadmod Graph</h1>
        <span class="badge">WebGL</span>
        <span class="stat">Nodes:<span class="stat-value">1</span></span>
        <span class="stat">Reachable:<span class="stat-value green">1</span></span>
        <span class="stat">Dead:<span class="stat-value red">0</span></span>
        <span class="stat">Edges:<span class="stat-value">4</span></span>
    </div>

    <div id="canvas-container"></div>
    <div id="fps">FPS: --</div>

    <div id="controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">‚àí</button>
        <button id="reset" title="Reset View">R</button>
        <button id="toggle-bundling" title="Edge Bundling" class="active">B</button>
        <button id="toggle-clusters" title="Cluster Gravity" class="active">C</button>
        <button id="toggle-sim" title="Pause Simulation">‚è∏</button>
    </div>

    <div id="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #90EE90;"></div>
            <span>Reachable</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #F08080;"></div>
            <span>Dead</span>
        </div>
    </div>

    <div id="inspector">
        <h2>üìã Module Inspector</h2>
        <div id="inspector-content">
            <p class="empty">Click a node to inspect</p>
        </div>
    </div>

    <script>
    (function() {
        const nodes = [{ "id": "main", "label": "main", "status": "reachable", "path": "\\\\?\\C:\\deadmod\\deadmod-cli\\src\\main.rs", "cluster": "main" }];
        const edges = [];
        const clusters = [{ "id": "main", "index": 0 }];

        // Settings
        let edgeBundling = true;
        let clusterGravity = true;
        let simRunning = true;

        // PixiJS setup
        const container = document.getElementById('canvas-container');
        const app = new PIXI.Application({
            resizeTo: container,
            backgroundColor: 0x0d0d1a,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        container.appendChild(app.view);

        // Containers
        const worldContainer = new PIXI.Container();
        const edgeGraphics = new PIXI.Graphics();
        const nodeContainer = new PIXI.Container();

        worldContainer.addChild(edgeGraphics);
        worldContainer.addChild(nodeContainer);
        app.stage.addChild(worldContainer);

        // Colors
        const ALIVE_COLOR = 0x90EE90;
        const DEAD_COLOR = 0xF08080;
        const CLUSTER_COLORS = [0xe94560, 0x0f3460, 0x533483, 0x16c79a, 0xf7be16,
                                0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96c93d, 0xdfe6e9];

        const clusterColorMap = {};
        clusters.forEach((c, i) => { clusterColorMap[c.id] = CLUSTER_COLORS[i % CLUSTER_COLORS.length]; });

        // Node state
        const nodeMap = {};
        const nodeSprites = {};
        let selectedNode = null;

        // Initialize nodes
        nodes.forEach((n, i) => {
            const angle = (i / nodes.length) * Math.PI * 2;
            const radius = Math.min(400, nodes.length * 12);
            nodeMap[n.id] = {
                ...n,
                x: Math.cos(angle) * radius + (Math.random() - 0.5) * 100,
                y: Math.sin(angle) * radius + (Math.random() - 0.5) * 100,
                vx: 0, vy: 0,
            };

            // Create sprite
            const g = new PIXI.Graphics();
            const color = n.status === 'dead' ? DEAD_COLOR : ALIVE_COLOR;
            g.beginFill(color, 0.9);
            g.lineStyle(2, n.status === 'dead' ? 0xcc4444 : 0x44aa44);
            g.drawRoundedRect(-30, -12, 60, 24, 6);
            g.endFill();

            // Cluster dot
            const clusterColor = clusterColorMap[n.cluster] || 0x666666;
            g.beginFill(clusterColor);
            g.drawCircle(22, -6, 4);
            g.endFill();

            // Label
            const label = new PIXI.Text(n.label.length > 10 ? n.label.slice(0, 8) + '..' : n.label, {
                fontFamily: 'Segoe UI',
                fontSize: 11,
                fill: 0x1a1a2e,
                fontWeight: 'bold',
            });
            label.anchor.set(0.5);
            g.addChild(label);

            g.eventMode = 'static';
            g.cursor = 'pointer';
            g.on('pointerdown', () => selectNode(n.id));

            nodeContainer.addChild(g);
            nodeSprites[n.id] = g;
        });

        // Adjacency
        const inbound = {};
        const outbound = {};
        nodes.forEach(n => { inbound[n.id] = []; outbound[n.id] = []; });
        edges.forEach(e => {
            if (inbound[e.to]) inbound[e.to].push(e.from);
            if (outbound[e.from]) outbound[e.from].push(e.to);
        });

        // Cluster centers
        const clusterCenters = {};
        function updateClusterCenters() {
            clusters.forEach(c => { clusterCenters[c.id] = { x: 0, y: 0, count: 0 }; });
            Object.values(nodeMap).forEach(n => {
                if (clusterCenters[n.cluster]) {
                    clusterCenters[n.cluster].x += n.x;
                    clusterCenters[n.cluster].y += n.y;
                    clusterCenters[n.cluster].count++;
                }
            });
            Object.values(clusterCenters).forEach(c => {
                if (c.count > 0) { c.x /= c.count; c.y /= c.count; }
            });
        }

        // Physics
        function simulate() {
            if (!simRunning) return;

            const allNodes = Object.values(nodeMap);
            if (clusterGravity) updateClusterCenters();

            // Repulsion
            for (let i = 0; i < allNodes.length; i++) {
                for (let j = i + 1; j < allNodes.length; j++) {
                    const a = allNodes[i], b = allNodes[j];
                    let dx = b.x - a.x, dy = b.y - a.y;
                    let dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    if (dist > 600) continue;
                    let force = 6000 / (dist * dist);
                    let fx = (dx / dist) * force, fy = (dy / dist) * force;
                    a.vx -= fx; a.vy -= fy;
                    b.vx += fx; b.vy += fy;
                }
            }

            // Edge attraction
            edges.forEach(e => {
                const a = nodeMap[e.from], b = nodeMap[e.to];
                if (!a || !b) return;
                let dx = b.x - a.x, dy = b.y - a.y;
                let dist = Math.sqrt(dx * dx + dy * dy) || 1;
                let force = (dist - 120) * 0.04;
                let fx = (dx / dist) * force, fy = (dy / dist) * force;
                a.vx += fx; a.vy += fy;
                b.vx -= fx; b.vy -= fy;
            });

            // Center gravity
            allNodes.forEach(n => {
                n.vx -= n.x * 0.0008;
                n.vy -= n.y * 0.0008;
            });

            // Cluster gravity
            if (clusterGravity) {
                allNodes.forEach(n => {
                    const c = clusterCenters[n.cluster];
                    if (c && c.count > 1) {
                        n.vx += (c.x - n.x) * 0.003;
                        n.vy += (c.y - n.y) * 0.003;
                    }
                });
            }

            // Apply
            allNodes.forEach(n => {
                n.vx *= 0.88; n.vy *= 0.88;
                n.x += n.vx; n.y += n.vy;
            });
        }

        // Drawing
        function drawEdges() {
            edgeGraphics.clear();

            edges.forEach(e => {
                const a = nodeMap[e.from], b = nodeMap[e.to];
                if (!a || !b) return;

                const isDead = a.status === 'dead' || b.status === 'dead';
                edgeGraphics.lineStyle(1.5, isDead ? 0xF08080 : 0x555555, isDead ? 0.4 : 0.5);

                if (edgeBundling) {
                    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
                    let cpx, cpy;
                    if (a.cluster === b.cluster && clusterCenters[a.cluster]) {
                        const c = clusterCenters[a.cluster];
                        cpx = mx + (c.x - mx) * 0.35;
                        cpy = my + (c.y - my) * 0.35;
                    } else {
                        cpx = mx * 0.75; cpy = my * 0.75;
                    }
                    edgeGraphics.moveTo(a.x, a.y);
                    edgeGraphics.quadraticCurveTo(cpx, cpy, b.x, b.y);
                } else {
                    edgeGraphics.moveTo(a.x, a.y);
                    edgeGraphics.lineTo(b.x, b.y);
                }

                // Arrow
                const angle = Math.atan2(b.y - a.y, b.x - a.x);
                const dist = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
                const ratio = Math.max(0, (dist - 35) / dist);
                const ax = a.x + (b.x - a.x) * ratio;
                const ay = a.y + (b.y - a.y) * ratio;
                const al = 8;
                edgeGraphics.moveTo(ax, ay);
                edgeGraphics.lineTo(ax - al * Math.cos(angle - 0.4), ay - al * Math.sin(angle - 0.4));
                edgeGraphics.moveTo(ax, ay);
                edgeGraphics.lineTo(ax - al * Math.cos(angle + 0.4), ay - al * Math.sin(angle + 0.4));
            });
        }

        function updateNodePositions() {
            Object.entries(nodeMap).forEach(([id, n]) => {
                const sprite = nodeSprites[id];
                if (sprite) {
                    sprite.x = n.x;
                    sprite.y = n.y;

                    // Selection highlight
                    if (selectedNode && selectedNode.id === id) {
                        sprite.alpha = 1;
                        sprite.scale.set(1.1);
                    } else {
                        sprite.alpha = 0.95;
                        sprite.scale.set(1);
                    }
                }
            });
        }

        // Inspector
        function selectNode(id) {
            const node = nodeMap[id];
            if (!node) return;
            selectedNode = node;

            const deps = outbound[id] || [];
            const dependents = inbound[id] || [];
            const deadDeps = deps.filter(d => nodeMap[d]?.status === 'dead').length;
            const deadDependents = dependents.filter(d => nodeMap[d]?.status === 'dead').length;

            document.getElementById('inspector-content').innerHTML = `
                <div class="section">
                    <h3>Module</h3>
                    <div class="value">${node.label}</div>
                    <span class="cluster-tag">${node.cluster}</span>
                </div>
                <div class="section">
                    <h3>Status</h3>
                    <div class="value" style="color: ${node.status === 'dead' ? '#F08080' : '#90EE90'}">${node.status.toUpperCase()}</div>
                </div>
                <div class="section">
                    <h3>Statistics</h3>
                    <div class="stat-row"><span class="stat-label">Dependencies</span><span class="stat-num">${deps.length}</span></div>
                    <div class="stat-row"><span class="stat-label">Dead deps</span><span class="stat-num red">${deadDeps}</span></div>
                    <div class="stat-row"><span class="stat-label">Dependents</span><span class="stat-num">${dependents.length}</span></div>
                    <div class="stat-row"><span class="stat-label">Dead dependents</span><span class="stat-num red">${deadDependents}</span></div>
                </div>
                <div class="section">
                    <h3>Dependencies (${deps.length})</h3>
                    <div class="dep-list">
                        ${deps.length ? deps.map(d => `<div class="dep-item ${nodeMap[d]?.status === 'dead' ? 'dead' : ''}" onclick="window.selectNode('${d}')">${d}</div>`).join('') : '<span class="empty">None</span>'}
                    </div>
                </div>
                <div class="section">
                    <h3>Dependents (${dependents.length})</h3>
                    <div class="dep-list">
                        ${dependents.length ? dependents.map(d => `<div class="dep-item ${nodeMap[d]?.status === 'dead' ? 'dead' : ''}" onclick="window.selectNode('${d}')">${d}</div>`).join('') : '<span class="empty">None</span>'}
                    </div>
                </div>
                <div class="section">
                    <h3>Path</h3>
                    <div class="value" style="font-size: 10px; word-break: break-all; color: #666;">${node.path}</div>
                </div>
            `;

            // Center on node
            worldContainer.x = app.screen.width / 2 - node.x * worldContainer.scale.x;
            worldContainer.y = app.screen.height / 2 - node.y * worldContainer.scale.y;
        }
        window.selectNode = selectNode;

        // Pan/Zoom
        let dragging = false, lastX = 0, lastY = 0;
        app.view.addEventListener('pointerdown', e => {
            dragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        app.view.addEventListener('pointermove', e => {
            if (!dragging) return;
            worldContainer.x += e.clientX - lastX;
            worldContainer.y += e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        app.view.addEventListener('pointerup', () => { dragging = false; });
        app.view.addEventListener('pointerleave', () => { dragging = false; });

        app.view.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const rect = app.view.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            const wx = (mx - worldContainer.x) / worldContainer.scale.x;
            const wy = (my - worldContainer.y) / worldContainer.scale.y;

            worldContainer.scale.x *= delta;
            worldContainer.scale.y *= delta;
            worldContainer.scale.x = Math.max(0.1, Math.min(4, worldContainer.scale.x));
            worldContainer.scale.y = worldContainer.scale.x;

            worldContainer.x = mx - wx * worldContainer.scale.x;
            worldContainer.y = my - wy * worldContainer.scale.y;
        });

        // Controls
        document.getElementById('zoom-in').onclick = () => { worldContainer.scale.set(Math.min(4, worldContainer.scale.x * 1.2)); };
        document.getElementById('zoom-out').onclick = () => { worldContainer.scale.set(Math.max(0.1, worldContainer.scale.x * 0.8)); };
        document.getElementById('reset').onclick = () => {
            worldContainer.scale.set(1);
            worldContainer.x = app.screen.width / 2;
            worldContainer.y = app.screen.height / 2;
        };

        const bundleBtn = document.getElementById('toggle-bundling');
        bundleBtn.onclick = () => { edgeBundling = !edgeBundling; bundleBtn.classList.toggle('active', edgeBundling); };

        const clusterBtn = document.getElementById('toggle-clusters');
        clusterBtn.onclick = () => { clusterGravity = !clusterGravity; clusterBtn.classList.toggle('active', clusterGravity); };

        const simBtn = document.getElementById('toggle-sim');
        simBtn.onclick = () => {
            simRunning = !simRunning;
            simBtn.textContent = simRunning ? '‚è∏' : '‚ñ∂';
        };

        // FPS counter
        let frameCount = 0, lastTime = performance.now();
        const fpsEl = document.getElementById('fps');

        // Main loop
        worldContainer.x = app.screen.width / 2;
        worldContainer.y = app.screen.height / 2;

        app.ticker.add(() => {
            simulate();
            drawEdges();
            updateNodePositions();

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsEl.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
        });
    })();
    </script>
</body>
</html>